using System;
using System.Collections.Generic;
using System.Linq;
using MathNet.Numerics.LinearAlgebra;

namespace Engine.Geometry.GeodesicSphere
{
    /// <summary>
    /// A factory for producing icosaspheres (triangle-faced approximations of a sphere)
    /// </summary>
    public static class IcosasphereFactory
    {
        // Icosaspheres are generated by repeatedly subdividing the faces of an icosahedron, then projecting the resultant
        // vertices onto the sphere.

        /// <summary>
        /// Constructs the icosasphere with least number of vertices exceeding the specified minimum. 
        /// </summary>
        public static IPolyhedron Build(IPolyhedronOptions options)
        {
            var icosahedron = IcosahedronFactory.Build();
         
            // Calculate the number of times the icosahedron will have to be subdivided in order to meet the minimum
            // number of faces specification.
            var numberOfSubdivisions = NumberOfSubdivisionsRequired(options.MinimumNumberOfFaces);

            // Keep subdividing the icosahedron until it meets the minimum number of faces specification.
            for (int i = 0; i < numberOfSubdivisions; i++)
            {
                icosahedron = Subdivide(icosahedron);
            }

            // Project the subdivision of the icosahedron onto the sphere.
            return ProjectOntoSphere(icosahedron, options.Radius);
        }

        //TODO: There's a formula for this in Heikes & Randall, why are you doing it iteratively?
        // Calculates the number of subdivisions of an icosahedron required to exceed the given number of faces.
        private static double NumberOfSubdivisionsRequired(int minimumNumberOfFaces)
        {
            var vertices = 12;
            var edges = 30;
            var faces = 20;

            var subdivisions = 0;
            while (faces < minimumNumberOfFaces)
            {
                vertices = vertices + edges;
                edges = 2*edges + 3*faces;
                faces = 4*faces;
                
                subdivisions = subdivisions + 1;
            }

            return subdivisions;
        }

        #region Subdivision methods.
        // Creates a new icosahedron by subdividing the provided icosasphere.
        private static IPolyhedron Subdivide(IPolyhedron icosasphere)
        {
            // Map each edge of the old icosasphere to a new vertex
            var oldEdgesToNewVertices = CreateNewVerticesFrom(icosasphere.Edges);

            // Create the new faces (each represented by a list of vertices) from the old icosasphere and the new vertices 
            var newFaces = CreateFacesFrom(icosasphere.Faces, icosasphere.EdgesOf, oldEdgesToNewVertices);

            return new Polyhedron(newFaces);
        }

        // Subdivides each of the old faces into four to create the new faces. Three of the vertices used are drawn from 
        // the old icosahedron, three of them are drawn from the map of old edges -> new vertices.
        private static List<List<Vertex>> CreateFacesFrom(List<Face> oldFaces, Func<Face, List<Edge>> oldFacesToOldEdges, Dictionary<Edge, Vertex> oldEdgesToNewVertices)
        {
            var newFaces = new List<List<Vertex>>();
            foreach (var oldFace in oldFaces)
            {
                newFaces.AddRange(CreateNewFacesFrom(oldFace, oldFacesToOldEdges, oldEdgesToNewVertices));
            }

            return newFaces;
        }

        // Subdivides a single face into four.
        private static List<List<Vertex>> CreateNewFacesFrom(Face oldFace, Func<Face, List<Edge>> oldFacesToOldEdges, Dictionary<Edge, Vertex> oldEdgesToNewVertices)
        {
            var newFaces = new List<List<Vertex>>();
            
            var edges = oldFacesToOldEdges(oldFace);

            // For each vertex in the old face, construct a new face using it and the new vertices corresponding to the adjacent edges.
            foreach (var vertex in oldFace.Vertices)
            {
                var adjacentEdges = edges.Where(edge => edge.A == vertex || edge.B == vertex);
                var newVertices = adjacentEdges.Select(edge => oldEdgesToNewVertices[edge]).ToList();
                newVertices.Add(vertex);
                newFaces.Add(newVertices);
            }

            // Make the fourth face from the three new vertices corresponding to the edges of the old face
            var centralFace = edges.Select(edge => oldEdgesToNewVertices[edge]).ToList();
            newFaces.Add(centralFace);

            return newFaces;
        }

        // Creates a new vertex at the midpoint of each given edge.
        private static Dictionary<Edge, Vertex> CreateNewVerticesFrom(IEnumerable<Edge> edges)
        {
            return edges.Distinct().ToDictionary(edge => edge, edge => VertexAtMidpointOf(edge));
        }

        // Creates a vertex at the midpoint of the given edge.
        private static Vertex VertexAtMidpointOf(Edge edge)
        {
            var position = (edge.A.Position + edge.B.Position) / 2;

            return new Vertex(position);
        }
        #endregion

        // Project the vertices of the given polyhedron onto a sphere of the specified radius.
        private static IPolyhedron ProjectOntoSphere(IPolyhedron polyhedron, double radius)
        {
            var newVertex = 
                polyhedron.Vertices.
                ToDictionary(oldVertex => oldVertex, oldVertex => new Vertex(radius*oldVertex.Position.Normalize(2)));

            var newFaces =
                from face in polyhedron.Faces
                select face.Vertices.Select(oldVertex => newVertex[oldVertex]).ToList();

            return new Polyhedron(newFaces.ToList());
        }
    }
}
